---
title: "Evaluate drug and omics data for biomarker assessment"
author: "Sara gosline"
date: "2025-03-13"
output: html_document
---

This document is designed to be a working document where we can compare approaches to evaluate biomarkers of drug response across patient samples. We are collecting three types of data modalities: 1. RNA Sequencing 2. Global Proteomics 3. Phospho proteomics

We also have drug sensitivity data (single dose viability, some curves) for many drugs. The question to ask is which molecules can predict drug response across patients? How robust/extendable is this?

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(synapser)
library(ggplot2)
library(dplyr)
library(tidyr)


```

# Pull processed files from previous markdowns

We have already run the previous scripts and stored data on Synapse

```{r pull files}
source('cNF_helper_code.R')
##read in drug code
fits <- readr::read_tsv(synGet('syn69947322')$path)


##read in proteomic data
glong <- readr::read_csv(synGet('syn70078416')$path)
plong <- readr::read_csv(synGet('syn70078415')$path)


##read in transcrniptomic data
#TODO: process transcritpomic data into long format

```

## Format protein data to collect correlation values

Do simple correlations to identify putative trends in the data.

```{r make matrices of proteins}
library(pheatmap)

shared<-intersect(fits$improve_sample_id,glong$Specimen)
print(paste('Found',length(shared),'shared samples from',length(unique(fits$improve_sample_id)),'drug experiments and',length(unique(glong$Specimen)),'proteomic experiments'))

glob_dat<-glong|>ungroup()|>
  subset(Specimen%in%shared)|>
  dplyr::select(Specimen,Gene,correctedAbundance)|>
  tidyr::pivot_wider(names_from='Gene',values_from='correctedAbundance',values_fill=0,values_fn=mean)|>
  tibble::column_to_rownames('Specimen')
  

phos_dat<-plong|>ungroup()|>
  subset(Specimen%in%shared)|>
  dplyr::select(Specimen,site,correctedAbundance)|>
  tidyr::pivot_wider(names_from='site',values_from='correctedAbundance',values_fill=0,values_fn=mean)|>
  tibble::column_to_rownames('Specimen')



## drug data to matrix here
drug_dat <- fits|>subset(dose_response_metric=='uM_viability') |>
  dplyr::select(improve_sample_id,improve_drug_id,dose_response_value) |>
  tidyr::pivot_wider(names_from='improve_drug_id',values_from='dose_response_value',values_fn=mean) |>
  tibble::column_to_rownames('improve_sample_id')

##first let's plot the most efficatiious
drug_counts <- fits |>
  subset(dose_response_metric == 'uM_viability') |>
  group_by(improve_drug_id)|>
  distinct()|>
  summarize(meanResponse = mean(dose_response_value,na.rm=T), nMeasured = n_distinct(improve_sample_id),variability = sd(dose_response_value,na.rm=T))

drug_counts |>
  arrange(desc(meanResponse)) |>
  subset(meanResponse < 0.5) |>
  ggplot(aes(y=meanResponse,x=improve_drug_id,colour=nMeasured,size=variability))+geom_point()+ggtitle("most efficacious drugs")

drug_counts |>
  arrange(desc(variability))|>
  subset(variability > 0.15)|>
  as.data.frame()|>
  ggplot(aes(y=meanResponse,x=improve_drug_id,colour=nMeasured,size=variability))+geom_point()+ggtitle("most variable drugs")

fulldrugs <- drug_counts|>
  subset(nMeasured==nrow(drug_dat))

pheatmap(as.matrix(drug_dat[,fulldrugs$improve_drug_id]))



```

# Basic correlation tests

Can we simply find and rank proteins/psites/transcripts by correlation and do enrichment?

We can define a simple test to correlate features and drugs and assess significance and correct:

```{r correlation tests, warning=FALSE, error=FALSE, message = FALSE}

#this function computes correlations between all columns for each drug/feature matrix, rows are the sample identifiers
#also coputes significance
computeCors <- function(drug_dat,feat_dat,shared){

  cres <- cor(drug_dat[shared,],feat_dat[shared,],use='pairwise.complete.obs',method='spearman') |>
    as.data.frame() |>
    tibble::rownames_to_column('drug')|>
    tidyr::pivot_longer(cols=2:(1+ncol(feat_dat)),names_to='gene',values_to='cor') |>
    arrange(desc(cor))

  ##now lets try to get significance
  csig <- do.call(rbind,lapply(colnames(drug_dat),function(x){
    do.call(rbind,lapply(colnames(feat_dat),function(y){
    pval <- 1.0
    try(pval <- cor.test(drug_dat[shared,x],
                         feat_dat[shared,y],
                        use = 'pairwise.complete.obs',
                        method = 'spearman')$p.value,silent = TRUE)
    
      return(c(corp = pval,drug = x,gene = y))
    })) |> 
      as.data.frame() |> 
      mutate(fdr=p.adjust(unlist(corp),method='fdr'))
  })) |> 
    as.data.frame() |>
    mutate(drug = unlist(drug)) |>
    mutate(gene = unlist(gene))

  fullcors <- cres|>left_join(data.frame(csig)) |>
    mutate(direction=ifelse(cor<0,'neg','pos'))

  return(fullcors)
}

```

Now that we have a function we can compute correlations of each data type.

```{r compute feature cors, warning=FALSE, error=FALSE, message = FALSE}

gcor <- computeCors(drug_dat[,fulldrugs$improve_drug_id],glob_dat,shared) |>
  mutate(data='proteins')
pcor <- computeCors(drug_dat[,fulldrugs$improve_drug_id],phos_dat,shared) |>
  mutate(data = 'phosphosites')

allcor <- rbind(gcor,pcor)

corsummary<-allcor |> subset(fdr<0.25) |>
   group_by(drug,data,direction) |>
   summarize(features=n(),meanCor=mean(cor))


corsummary |>
  subset(features > 1) |>
  ggplot(aes(x = drug,y = features,fill = direction)) + 
    facet_grid(data~.) + 
    geom_bar(position='dodge',stat='identity') +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))


corsummary |>
  arrange(desc(features)) |>
  subset(features > 100) |>
  dplyr::select(drug,data,direction,features,meanCor)

```

Now we have the correlation values. what do we do with the?

## Correlation based enrichment
For each drug, how many terms do we see active? how many kinases?
```{r functional enrichment}
#TODO
library(leapR)


```

## Visualization
How should we visualize? Here is some older code
```{r plot cors, eval=FALSE}

plotCors <- function(features,druglist,dataType='proteins'){
  ##subset a list of features and drugs and plot those in a graph
  require(ggplot2)
  if(dataType=='proteins'){
    ptab<-glong|>dplyr::rename(feature='Gene')
  }else{
    ptab<-plong|>dplyr::rename(feature='site')
  }
  dtab<-fits|>
    subset(dose_response_metric=='uM_viability')|>
    dplyr::rename(Specimen='improve_sample_id',Drug='improve_drug_id')|>
    subset(Drug%in%druglist)
  
  
  ftab<-features|>left_join(ptab)|>left_join(dtab)|>
    subset(!is.na(Drug))
  
  feats <- unique(features$feature)
  plots <- lapply(feats,function(x){
    corval <- ftab[ftab$feature==x,'cor']
    #corval <- ftab[ftab$feature==x,'pCor']

      ftab|>subset(feature==x)|>
        ggplot(aes(x=correctedAbundance,y=dose_response_value,
                   col=Patient,size=1))+
    geom_point()+
    facet_grid(~Drug)+
      ggtitle(paste(x,'Drug correlation'))+
    scale_color_manual(values=pcols)
    })
  cowplot::plot_grid(plotlist= plots,ncol=2)

}

druglist<-c('Onalespib')
features<-subset(allcor,drug%in%druglist)|>
  subset(fdr<0.25)|>
  subset(abs(cor)>0.7)|>
  subset(data=='proteins')|>
  arrange(desc(abs(cor)))

plotCors(rename(features[1:10,],feature='gene'),druglist)

ggsave('onalespibFDR0.25Cors.pdf',height=20)

```

# Random forest predictor

Here we try to use random forest to extract predictive features. First we need to assess if the model can accurately predict drug response from the data. From those predictive models, we can extract features/biomarkers.

First we build the data frames needed - I've included cohort as a covariate but may remove it.

```{r random forest}
## separate out cohorts for prediction 
cohorts <- meta |>
  select(Specimen,cohort) |>
  distinct() |>
  tibble::column_to_rownames('Specimen')

##for each drug, build model of cohort + protein ~ drug response
#removed cohort for now
gdf <- as.data.frame(glob_dat)#|>mutate(cohort=cohorts[rownames(glob_dat),'cohort'])
gnas <- which(apply(gdf,2,function(x) any(is.na(x))))

pdf <- as.data.frame(phos_dat)#|>   mutate(cohort=cohorts[rownames(phos_dat),'cohort'])
pnas <- which(apply(pdf,2,function(x) any(is.na(x))))

mdf <- meta[-c(2,5),]|> ##have duplication here
  tibble::column_to_rownames('Specimen')


```

Now we can loop through every drug, build model, and assess accuracy.

```{r evaluate predictivty}

#trying ou tthis function tos ee how it goes
rfFeatures <- function(drug_dat,fdf, mdf){
 complete_drugs <- which(apply(drug_dat,2,
                            function(x) length(which(!is.na(x)))==length(x)))
  print(paste("Evaluating random forest for ",length(complete_drugs),'drugs'))
  all_preds <- do.call(rbind,lapply(names(complete_drugs),function(drug){
    
  dg <- fdf#[,-gnas]
  
  ##create the metadata df with the drug of interest
  dmdf <- mdf |>
    mutate(drug=drug_dat[rownames(mdf),drug])
  
  rf <- randomForest::randomForest(x=dg,
                                   y=drug_dat[rownames(dg),drug], 
                                   importance=TRUE,ntree=500)
  
  im <- randomForest::importance(rf)|>
    as.data.frame() |>
    mutate(drug=drug)
  pord <- intersect(rownames(mdf)[order(drug_dat[rownames(mdf),drug])],rownames(glob_dat))
  
  #pheatmap::pheatmap(t(glob_dat[pord,
  #                            rownames(im)]),annotation_col=dmdf,
  #                   cellheight=10,cluster_cols = TRUE)
  return(im)
  ##what do we return?x
  }))
  return(all_preds)
}


```

Now what do we do with the importance features?

```{r rf processing}

##get importance for global
gimp <- rfFeatures(drug_dat=drug_dat,fdf=gdf,mdf=mdf)

##get importance for phospho
pimp <- rfFeatures(drug_dat=drug_dat,fdf=pdf,mdf=mdf)

```


# Old correlation code, dont run

now we can visualize correlations

```{r check out HSP90s, eval=FALSE}

hsps<-unique(glong$Genes[grep('^HSP',glong$Genes)])

cor_hsps<-subset(allcor,gene%in%hsps)|>subset(drug=='Onalespib')|>subset(corp<0.2)
#print(paste('measured',length(hsps),'HSPs in global data of which', nrow(cor_hsps),' are correlated with Onalespib'))

plotCors(rename(cor_hsps,feature='gene'),c('Onalespib'))

ggsave('hspCorsOna.pdf',height=nrow(cor_hsps)*3)

hspp<-unique(plong$site[grep('^HSP',plong$site)])
cor_hspps<-subset(allcor,gene%in%hspp)|>subset(drug=='Onalespib')|>subset(corp<0.2)
#print(paste('measured',length(hspp),'HSPs in phospho data of which',nrow(cor_hspps),' are correlated with Onalespib'))

plotCors(rename(cor_hspps,feature='gene'),c('Onalespib'),'phospho')

ggsave('hspPhosphoCorsOna.pdf',height=nrow(cor_hspps)*3)


```

### Now lets look only at IC50 values

There are a few drugs for which we have IC50 values

```{r check ic50 cors,warning=FALSE,error=FALSE, eval=FALSE}

ifits<-subset(fits,dose_response_metric=='fit_ic50')

shared<-intersect(ifits$improve_sample_id,glong$Specimen)
print(paste('Found',length(shared),'shared samples'))

## a full join might be a challenge, maybe just take two matrices
drug_dat <- ifits|>
  dplyr::select(improve_sample_id,improve_drug_id,dose_response_value)|>
  tidyr::pivot_wider(names_from='improve_drug_id',values_from='dose_response_value',values_fn=mean)|>
  tibble::column_to_rownames('improve_sample_id')

gres<-cor(drug_dat[shared,],glob_dat[shared,],use='pairwise.complete.obs',method='pearson')|>
  as.data.frame()|>
    tibble::rownames_to_column('drug')|>
  tidyr::pivot_longer(cols=2:(1+ncol(glob_dat)),names_to='gene',values_to='pCor')|>
  arrange(desc(pCor))

##now lets try to get significance

gsig<-do.call(rbind,lapply(colnames(drug_dat),function(x){
  do.call(rbind,lapply(colnames(glob_dat),function(y){
    pval<-1.0
    try(pval<-cor.test(drug_dat[shared,x],glob_dat[shared,y],use='pairwise.complete.obs',method='pearson')$p.value,silent=TRUE)
    return(c(corp=pval,drug=x,gene=y))
    }
    ))|>as.data.frame()|>
    mutate(fdr=p.adjust(unlist(corp),method='fdr'))
  }))|>
  as.data.frame()|>
  mutate(drug=unlist(drug))|>
  mutate(gene=unlist(gene))

fullcors<-gres|>left_join(data.frame(gsig))|>mutate(data='global')

pres<-cor(drug_dat[shared,],phos_dat[shared,],use='pairwise.complete.obs',method='pearson')|>
    as.data.frame()|>
    tibble::rownames_to_column('drug')|>
  tidyr::pivot_longer(cols=2:(1+ncol(phos_dat)),names_to='site',values_to='pCor')|>
  arrange(desc(pCor))

##now lets look at correlations

psig<-do.call(rbind,lapply(colnames(drug_dat),function(x){
  do.call(rbind,lapply(colnames(phos_dat),function(y){
    pval<-1.0
    try(pval<-cor.test(drug_dat[shared,x],phos_dat[shared,y],use='pairwise.complete.obs',method='pearson')$p.value,silent=TRUE)
    return(c(corp=pval,drug=x,gene=y))
    }
    ))|>as.data.frame()|>
    mutate(fdr=p.adjust(unlist(corp),method='fdr'))
  }))|>as.data.frame()

fullpcors<-pres|>rename(gene='site')|>left_join(data.frame(psig))|>mutate(data='phospho')

#combine all correlations
allcor<-rbind(fullcors,fullpcors)|>
  mutate(direction=ifelse(pCor<0,'neg','pos'))


##lets count the correlations and plot

corsummary<-allcor|>subset(fdr<0.1)|>
  group_by(drug,data,direction)|>
  summarize(features=n(),meanCor=mean(pCor))

corsummary|>
  #subset(features>1)|>
  ggplot(aes(x=data,y=features,fill=drug))+
  facet_grid(~direction)+
  geom_bar(position='dodge',stat='identity')

```

Again we have onalespib with numerous significantly correlated proteins, and one phosphosite for digoxin showing up .

```{r plot individual sites, eval=FALSE}

druglist<-c('Onalespib')
features<-subset(allcor,drug%in%druglist)|>
  subset(fdr<0.05)|>
  subset(data=='global')

plotCors(rename(features,feature='gene'),druglist)


druglist<-c('Digoxin')
features<-subset(allcor,drug%in%druglist)|>
  subset(fdr<0.1)|>
  subset(data=='phospho')

#plotCors(rename(features,feature='gene'),druglist,data='phospho')



```

Now we can check the HSP proteins directly

```{r HSP correlation, eval=FALSE}
hsps<-unique(glong$Genes[grep('^HSP',glong$Genes)])

cor_hsps<-subset(allcor,gene%in%hsps)|>subset(drug=='Onalespib')|>subset(corp<0.05)

print(paste('measured',length(hsps),'HSPs in global data of which', nrow(cor_hsps),' are correlated with Onalespib'))

plotCors(rename(cor_hsps,feature='gene'),'Onalespib')

hspp<-unique(plong$site[grep('^HSP',plong$site)])
cor_hspps<-subset(allcor,gene%in%hspp)|>subset(drug=='Onalespib')|>subset(corp<0.1)

print(paste('measured',length(hspp),'HSPs in phospho data of which',nrow(cor_hspps),' are correlated with Onalespib'))
```

The IC50 result is similar to the viability. Now we can check AUC

```{r auc hsp check, error=FALSE, warning=FALSE, eval=FALSE}

ifits<-subset(fits,dose_response_metric=='auc')

shared<-intersect(ifits$improve_sample_id,glong$Specimen)
print(paste('Found',length(shared),'shared samples'))

## a full join might be a challenge, maybe just take two matrices
drug_dat <- ifits|>
  dplyr::select(improve_sample_id,improve_drug_id,dose_response_value)|>
  tidyr::pivot_wider(names_from='improve_drug_id',values_from='dose_response_value',values_fn=mean)|>
  tibble::column_to_rownames('improve_sample_id')

gres<-cor(drug_dat[shared,],glob_dat[shared,],use='pairwise.complete.obs',method='pearson')|>
  as.data.frame()|>
    tibble::rownames_to_column('drug')|>
  tidyr::pivot_longer(cols=2:(1+ncol(glob_dat)),names_to='gene',values_to='pCor')|>
  arrange(desc(pCor))

##now lets try to get significance

gsig<-do.call(rbind,lapply(colnames(drug_dat),function(x){
  do.call(rbind,lapply(colnames(glob_dat),function(y){
    pval<-1.0
    try(pval<-cor.test(drug_dat[shared,x],glob_dat[shared,y],use='pairwise.complete.obs',method='pearson')$p.value,silent=TRUE)
    return(c(corp=pval,drug=x,gene=y))
    }
    ))|>as.data.frame()|>
    mutate(bh_p=p.adjust(unlist(corp),method='BH'))
  }))|>
  as.data.frame()|>
  mutate(drug=unlist(drug))|>
  mutate(gene=unlist(gene))

fullcors<-gres|>left_join(data.frame(gsig))|>mutate(data='global')

pres<-cor(drug_dat[shared,],phos_dat[shared,],use='pairwise.complete.obs',method='pearson')|>
    as.data.frame()|>
    tibble::rownames_to_column('drug')|>
  tidyr::pivot_longer(cols=2:(1+ncol(phos_dat)),names_to='site',values_to='pCor')|>
  arrange(desc(pCor))

##now lets look at correlations

psig<-do.call(rbind,lapply(colnames(drug_dat),function(x){
  do.call(rbind,lapply(colnames(phos_dat),function(y){
    pval<-1.0
    try(pval<-cor.test(drug_dat[shared,x],phos_dat[shared,y],use='pairwise.complete.obs',method='pearson')$p.value,silent=TRUE)
    return(c(corp=pval,drug=x,gene=y))
    }
    ))|>as.data.frame()|>
    mutate(bh_p=p.adjust(unlist(corp),method='BH'))
  }))|>as.data.frame()

fullpcors<-pres|>rename(gene='site')|>left_join(data.frame(psig))|>mutate(data='phospho')

#combine all correlations
allcor<-rbind(fullcors,fullpcors)|>
  mutate(direction=ifelse(pCor<0,'neg','pos'))


##lets count the correlations and plot

corsummary<-allcor|>subset(bh_p<0.1)|>
  group_by(drug,data,direction)|>
  summarize(features=n(),meanCor=mean(pCor))

corsummary|>
  #subset(features>1)|>
  ggplot(aes(x=data,y=features,fill=drug))+facet_grid(~direction)+geom_bar(position='dodge',stat='identity')

print(corsummary)

```

```{r HSP correlation again, eval=FALSE}
hsps<-unique(glong$Genes[grep('^HSP',glong$Genes)])

cor_hsps<-subset(allcor,gene%in%hsps)|>s
ubset(drug=='Onalespib')|>subset(corp<0.05)
print(paste('measured',length(hsps),'HSPs in global data of which', nrow(cor_hsps),' are correlated with Onalespib'))
cor_hsps

plotCors(rename(cor_hsps, feature='gene'),'Onalespib')

hspp<-unique(plong$site[grep('^HSP',plong$site)])
cor_hspps<-subset(allcor,gene%in%hspp)|>subset(drug=='Onalespib')|>subset(corp<0.1)
print(paste('measured',length(hspp),'HSPs in phospho data of which',nrow(cor_hspps),' are correlated with Onalespib'))
```
